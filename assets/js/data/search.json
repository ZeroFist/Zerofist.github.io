[ { "title": "N과 M (6)", "url": "/posts/N%EA%B3%BC-M-(7)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-27 00:00:00 +0900", "snippet": "N과 M (6)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력 가능 =&gt; 방문 여부 체크 X#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tansarr[cnt] = arr[i];\t\tdfs(cnt + 1);\t}}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + N);\tdfs(0);\treturn 0;}" }, { "title": "N과 M (6)", "url": "/posts/N%EA%B3%BC-M-(6)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (6)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력해해서는 안된다. =&gt; 방문 여부 체크사전 순 증가하는 순서로 출력해야한다. =&gt; 배열 정렬오름차순인 수열만 출력한다 =&gt; 출력전 수열이 오름차순인지 체크#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };bool isvisited[10001] = { false, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M - 1; i++)\t\t{\t\t\tif (ansarr[i] &gt;= ansarr[i + 1])\t\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\t\tif (isvisited[arr[i]] == true)\t\t\tcontinue;\t\telse\t\t\tansarr[cnt] = arr[i];\t\tisvisited[arr[i]] = true;\t\tdfs(cnt + 1);\t\tisvisited[arr[i]] = false;\t}\treturn;}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + (N + 1));\tdfs(0);\treturn 0;}" }, { "title": "N과 M (5)", "url": "/posts/N%EA%B3%BC-M-(5)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (5)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력해해서는 안된다. =&gt; 방문 여부 체크사전 순 증가하는 순서로 출력해야한다. =&gt; 배열 정렬#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };bool isvisited[10001] = { false, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\t\tif (isvisited[arr[i]] == true)\t\t\tcontinue;\t\telse\t\t\tansarr[cnt] = arr[i];\t\tisvisited[arr[i]] = true;\t\tdfs(cnt + 1);\t\tisvisited[arr[i]] = false;\t}\treturn;}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + (N + 1));\tdfs(0);\treturn 0;}" }, { "title": "N과 M (3)", "url": "/posts/N%EA%B3%BC-M-(4)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (4)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.조건 중 중요한 것은,같은 수를 여러 번 골라도 된다.고른 수열은 비내림차순이어야 한다.길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.다음과 같이 다음 숫자가 이전 숫자보다 작아서는 안된다.따라서 작은 경우 출력하지 않은 형태로 간단히 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, M;bool isvisited[8] = {false, };int arr[8] = { 0, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M - 1; i++)\t\t{\t\t\tif (arr[i] &gt; arr[i + 1])\t\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", arr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn ;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tarr[cnt] = i;\t\tdfs(cnt + 1);\t}}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tdfs(0);\treturn 0;}" }, { "title": "N과 M (3)", "url": "/posts/N%EA%B3%BC-M-(3)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (3)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.같은 수를 여러번 체크해도 되므로 방문 문자열은 굳이 쓰지 않아도 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int N, M;int arr[8] = { 0, };bool isvisited[8] = {false,};void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t}\t\tcout &lt;&lt; '\\n';\t\treturn ;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tisvisited[i] = true;\t\tarr[cnt] = i;\t\tdfs(cnt + 1);\t\tisvisited[i] = false;\t}}int main(){\t\tscanf(\"%d %d\", &amp;N, &amp;M);\tdfs(0);\treturn 0;}" }, { "title": "괄호 회전하기", "url": "/posts/%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Stack", "date": "2022-07-22 00:00:00 +0900", "snippet": "괄호 회전하기스택 문제로 추가적인 조건으로 문자열을 한칸씩 shift register 처럼 밀어가며 체크해야하는 문제이다.이를 반복문과 문자열 회전 부분을 추가하여 문제를 해결한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int solution(string s) { int answer = 0; for(int i = 0; i &lt; s.length(); i++) { stack&lt;int&gt; st; bool flag = true; for(int j = 0; j &lt; s.length(); j++) { if(s[j] == '[' || s[j] == '(' || s[j] == '{') { st.push(s[j]); } else if(s[j] == ']') { if(st.top() == '[') st.pop(); else { flag = false; break; } } else if(s[j] == '}') { if(st.top() == '{') st.pop(); else { flag = false; break; } } else if(s[j] == ')') { if(st.top() == '(') st.pop(); else { flag = false; break; } } } if(st.empty() &amp;&amp; flag == true) answer++; /* rotate */ char ch = s.front(); s.erase(s.begin()); s.push_back(ch); } return answer;}" }, { "title": "이친수", "url": "/posts/%EC%9D%B4%EC%B9%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-07-21 00:00:00 +0900", "snippet": "이친수DP 문제로 DP[1] 의 경우 1, DP[2] 의 경우 10DP[3] 의 경우 100, 101DP[4] 의 경우 1000, 1001, 1010DP[5] 의 경우 10000, 10001, 10101, 10100, 10010…을 미루어 보아 하기 코드와 같은 점화식을 짤 수 있다.해당 패턴은 트리 구조로 손으로 써 내려가면 경우의 수를 빨리 찾을 수 있다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N;long long dp[91] = { 0, };int main(){\tscanf(\"%d\", &amp;N);\tdp[1] = 1;\tdp[2] = 1;\tfor (int i = 3; i &lt;= N; i++)\t{\t\tdp[i] = dp[i - 1] + dp[i - 2];\t}\tcout &lt;&lt; dp[N] &lt;&lt; '\\n';\treturn 0;}" }, { "title": "로또", "url": "/posts/%EB%A1%9C%EB%98%90/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-20 00:00:00 +0900", "snippet": "로또순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.dfs 함수에서 start 매개변수의 경우 lotto의 인덱스를 가리키고 depth 매개 변수의 경우 S의 인덱스를 나타낸다.dfs(0, 0) 부터 시작해서 dfs(6, 6)까지 진행하며 첫 번째 결과를 출력하고 다시 dfs(5, 5)로 돌아가 i++이 된 상태로 S[depth] 에 lotto[i] 가 저장된다.이상태로 S[5] 가 들어갈 수 있는 값이 모두 결정되면 dfs(4, 4)로 돌아가 S[4], S[5] 가 결정 될 수 있는 경우의 수를 출력한다…이 과정을 반복하며 모든 순열을 출력하고 함수가 종료된다.재귀 함수로 설계하므로 종료조건에 대해서 고민하고 return; 을 붙여주자.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int lotto[14] = {0, };int S[6] = { 0, };void dfs(int start, int depth){\tif (depth == 6)\t{\t\tfor (int i = 0; i &lt; 6; i++)\t\t{\t\t\tprintf(\"%d \",S[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = start; i &lt; n; i++)\t{\t\tS[depth] = lotto[i];\t\tdfs(i + 1, depth + 1);\t}}int main(){\twhile (true)\t{\t\tscanf(\"%d\", &amp;n);\t\tif (n == 0)\t\t\tbreak;\t\tmemset(lotto, 0x0, sizeof(int) * 13);\t\tfor (int i = 0; i &lt; n; i++)\t\t{\t\t\tscanf(\"%d\", &amp;lotto[i]);\t\t}\t\tdfs(0, 0);\t\tprintf(\"\\n\");\t}\t\treturn 0;}" }, { "title": "예산", "url": "/posts/%EC%98%88%EC%82%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-16 00:00:00 +0900", "snippet": "예산이분 탐색 문제#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[10000] = { 0, };int bsearch(int end){\tint start = 0, sum = 0, cost = 0;\twhile (start &lt;= end)\t{\t\tsum = 0;\t\tcost = (start + end) / 2;\t\tfor (int i = 0; i &lt; N; i++)\t\t{\t\t\tif (arr[i] &gt; cost)\t\t\t\tsum += cost;\t\t\telse\t\t\t\tsum += arr[i];\t\t}\t\tif (sum &lt;= M)\t\t\tstart = cost + 1;\t\telse\t\t\tend = cost - 1;\t}\treturn end;}int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tscanf(\"%d\", &amp;M);\tsort(arr, arr + N);\tprintf(\"%d\", bsearch(arr[N - 1]));\treturn 0;}" }, { "title": "삼각형과 세 변", "url": "/posts/%EC%82%BC%EA%B0%81%ED%98%95%EA%B3%BC-%EC%84%B8-%EB%B3%80/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-16 00:00:00 +0900", "snippet": "삼각형과 세 변단순 구현 문제로 삼각형의 세 변 길이를 보고 삼각형의 형태를 파악하는 문제이다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){\tvector&lt;int&gt; v;\twhile (true)\t{\t\tfor (int i = 0; i &lt; 3; i++)\t\t{\t\t\tint len;\t\t\tscanf(\"%d\", &amp;len);\t\t\tv.push_back(len);\t\t}\t\tsort(v.begin(), v.end(), greater&lt;int&gt;());\t\tif (v[0] == 0)\t\t\tbreak;\t\tif (v[0] &gt;= (v[1] + v[2]))\t\t{\t\t\tprintf(\"Invalid\\n\");\t\t}\t\telse if (v[0] == v[1] &amp;&amp; v[1] == v[2])\t\t{\t\t\tprintf(\"Equilateral\\n\");\t\t}\t\telse if (v[0] == v[1] || v[1] == v[2])\t\t{\t\t\tprintf(\"Isosceles\\n\");\t\t}\t\telse\t\t{\t\t\tprintf(\"Scalene\\n\");\t\t}\t\tv.clear();\t}\t\treturn 0;}" }, { "title": "최소 힙", "url": "/posts/%EC%B5%9C%EC%86%8C-%ED%9E%99/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-14 00:00:00 +0900", "snippet": "최소 힙우선순위 큐를 이용하여 최소 힙을 구현하고 0이 나올 때마다 최소 값을 출력하는 로직을 설계한다.=&gt; 우선순위 큐에 greater 를 사용한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int main(void){\tint N, x;\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;x);\t\tif(x != 0)\t\t\tpq.push(x);\t\tif (x == 0)\t\t{\t\t\tif (pq.empty())\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t\tcontinue;\t\t\t}\t\t\t\t\t\t\tprintf(\"%d\\n\", pq.top());\t\t\tpq.pop();\t\t}\t}\treturn 0;}" }, { "title": "올림픽", "url": "/posts/%EC%98%AC%EB%A6%BC%ED%94%BD/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-13 00:00:00 +0900", "snippet": "올림픽단순 구현 문제금메달 비교 =&gt; 동등? =&gt; 은메달 비교 =&gt; 동등? =&gt; 동메달 비교#include &lt;iostream&gt;using namespace std;int N, K;int gold[1001] = { 0, }, silver[1001] = { 0, }, bronze[1001] = { 0, };int main(void){\tint place = 1;\tscanf(\"%d %d\", &amp;N, &amp;K);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint country;\t\tscanf(\"%d\", &amp;country);\t\tscanf(\"%d %d %d\", &amp;gold[country], &amp;silver[country], &amp;bronze[country]);\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tif (gold[i] &gt; gold[K])\t\t{\t\t\tplace++;\t\t}\t\telse\t\t{\t\t\tif (gold[i] == gold[K])\t\t\t{\t\t\t\tif (silver[i] &gt; silver[K])\t\t\t\t{\t\t\t\t\tplace++;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (silver[i] == silver[K])\t\t\t\t\t{\t\t\t\t\t\tif (bronze[i] &gt; bronze[K])\t\t\t\t\t\t\tplace++;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", place);\treturn 0;}" }, { "title": "책 리뷰(코딩의 기술)", "url": "/posts/Book_Review(%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0)/", "categories": "Book Review", "tags": "Book Review", "date": "2022-07-13 00:00:00 +0900", "snippet": "책 리뷰(코딩의 기술)1장. 읽기 좋은 코드를 작성하는 기술읽기 좋은 코드는 가독성을 지표로 표현할 수 있다. 이러한 코드의 가독성은 코드의 보수성에 영향을 주는데,여기서 코드의 보수성이란 코드의 변경, 추가 테스트가 얼마나 용이한지를 의미한다.읽기 좋은 코드를 작성하는 요령을 간단히 설명하면,“복잡한 코드 문제를 작게 나누고, 읽기 좋은 이름을 붙여 정리하자”이다.1.2 변수와 상수변수 이름의 경우 의도 파악 등을 위해 명확한 이름을 붙인다.상수의 경우 우리가 글로 이해할 수 있는 이름의 열거형을 선언하여 표현하면 코드의 가독성을 높일 수 있다.typedef enum state_e{ STATE_INIT = 0, STATE_STANDBY, STATE_GO, STATE_STOP};1.3 조건식과 계산식1.3.1 설명 전용 변수 사용if-statement와 같은 조건 문에 복잡한 조건이 사용되는 경우 설명 전용 변수를 사용한다.const bool isZero = (y != 0);const bool isStateFail = (state == STATE_FAIL);const bool Judge = (!isZero &amp;&amp; !isStateFail);if(Judge){}1.3.2 조건식 함수화bool isZero() { return y != 0; } bool isStateFail() { return state == STATE_FAIL; } bool Judge() { return (!isZero &amp;&amp; !isStateFail); }1.3.3 설명 전용 변수 사용설명 전용 변수를 사용하여 가독성을 높인다.const int maxSpeed = FACTOR * 2.0U * MAX_WHEEL_SPEED;const int minSpeed = FACTOR * 2.0U * MIN_WHEEL_SPEED;if(speed &gt; maxSpeed){}else if(speed &lt;= maxSpeed &amp;&amp; speed &gt; minSpeed){}else{}1.3.4 계산식 함수화계산식을 함수화 하여 그냥 봐도 무엇을 하는 코드인지 알게한다.int FindMaxSpeed(int x){ return FACTOR * x * MAX_WHEEL_SPEED;}int FindMinSpeed(int x){ return FACTOR * x * MIN_WHEEL_SPEED; }void speedfunc(){ const int maxSpeed = FindMaxSpeed(); const int minSpeed = FindMinSpeed(); if(speed &gt; maxSpeed) { } else if(speed &lt;= maxSpeed &amp;&amp; speed &gt; minSpeed) { } else { }}2장. 간단할 설계를 위한 원칙과 패턴3장. 소스 코드 품질 측정" }, { "title": "우선순위 큐(Priority_queue)", "url": "/posts/Priority_queue/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-07-12 00:00:00 +0900", "snippet": "우선순위 큐(Priority_queue)우선순위 큐란?큐의 모든 원소 중에서 가장 큰 값이 Top 위치에 위치하도록 우선순위가 크도록 설계되어 있는 큐를 말한다.내부적으로는 Heap 자료구조를 사용한다.C++에서 우선순위 큐의 메소드추가 및 삭제push() : 우선순위 큐에 원소를 추가한다pop() : 우선순위 큐에서 Top의 원소를 제거한다서칭top() : 우선순위 큐에서 Top에 있는 원소 즉 우선순위가 높은 원소를 반환한다Etc.empty() : 우선순위 큐가 비어있으면 True를 반환하고 그렇지 않으면 False를 반환한다size() : 우선순위 큐에 포함되어 있는 원소의 수를 반환한다선언priority_queue&lt;자료형, Container, 비교함수&gt; 변수명ex) 오름차순으로 정렬되는 우선순위 큐priority_queue&lt;int , vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;" }, { "title": "N번째 큰 수", "url": "/posts/N%EB%B2%88%EC%A7%B8-%ED%81%B0-%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, Priority Queue", "date": "2022-07-12 00:00:00 +0900", "snippet": "N번째 큰 수우선순위 큐 문제로 우선 순위 큐에 데이터를 오름차순 정렬 형태로 채워 놓고,큐의 사이즈가 N보다 커지면 하나씩 꺼내 최종적으로 큐에 N개만 남게한다.이렇게 되면 Queue의 Top은 N 번째로 큰 숫자가 된다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void){\tint N, x;\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N * N; i++)\t{\t\t\t\tscanf(\"%d\", &amp;x);\t\tpq.push(x);\t\tif (pq.size() &gt; N)\t\t\tpq.pop();\t}\t\tcout &lt;&lt; pq.top() &lt;&lt; '\\n';}" }, { "title": "줄세우기", "url": "/posts/%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Simulation", "date": "2022-07-11 00:00:00 +0900", "snippet": "줄세우기얼핏 정렬를 해야하는 문제처럼 보이지만, 현재 위치에서 나보다 큰 숫자가 있을 경우 바꾸고 한 칸씩 땡기는 것을 카운트만 하면 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int P;int arr[20];int main(void){\tscanf(\"%d\", &amp;P);\tfor (int i = 0; i &lt; P; i++)\t{\t\tint T;\t\tint sum = 0;\t\tscanf(\"%d\", &amp;T);\t\tfor (int j = 0; j &lt; 20; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[j]);\t\t}\t\tfor (int j = 0; j &lt; 20; j++)\t\t{\t\t\tfor (int k = 0; k &lt; j; k++)\t\t\t{\t\t\t\tif (arr[j] &lt; arr[k])\t\t\t\t\tsum++;\t\t\t}\t\t}\t\tcout &lt;&lt; T &lt;&lt; \" \" &lt;&lt; sum &lt;&lt; '\\n';\t}}" }, { "title": "함수포인터", "url": "/posts/%ED%95%A8%EC%88%98%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-10 00:00:00 +0900", "snippet": "함수포인터함수의 이름은 하나의 Symbol 이고 Symbol은 하나의 물리적 주소를 가진다.즉 실제 함수의 이름이 의미하는 것은 함수의 시작 주소를 의미한다.이를 통해 우리는 포인터를 활용하면 원하는 함수를 같은 지점에서 그 때 그 때 사정에 따라 다른 함수를 실행 시킬 수 있게된다.함수 포인터의 선언포인터 함수의 선언의 경우 다음과 같이 이루어진다.자료형 (함수 포인터 이름)(매개변수)int (funcp)(int);=&gt; 이는 int 형 return 값을 가지고 int 형 매개 변수를 하나 가지는 포인터 함수를 의미한다.함수 포인터 배열다음은 사칙연산 함수를 호출하는 함수 포인터 배열과 그 초기화 이다.int(* funcp[4])(int,int) = { add, sub, mul, div};함수 포인터와 Typedef를 활용한 구조체함수 포인터의 경우 역시 구조체 멤버로 사용할 수 있다.struct 구조체 이름{ 자료형(* 함수포인터 이름)(매개변수);}typedef struct calc_t{ int (*funcp)(int, int);}int main(){ struct calc_t ct; c.funcp = add;}" }, { "title": "돌 게임", "url": "/posts/%EB%8F%8C-%EA%B2%8C%EC%9E%84/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-10 00:00:00 +0900", "snippet": "돌 게임결과적으로 짝수와 홀수를 판단하는 문제로무조건 1개 혹은 3개를 가져갈 수 있어 짝수일 때는 창영이, 홀수일 때는 상근이 이기게 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void){\tint N;\tscanf(\"%d\", &amp;N);\tstring answer = ((N &amp; 1) == 0) ? \"CY\" : \"SK\";\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "Little Endian, Big Endian", "url": "/posts/Little_Endian_Big_Endian/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-10 00:00:00 +0900", "snippet": "Little Endian, Big Endian모든 프로세서들은 Little Endian, Big Endian 둘 중 하나의 order 를 따른다.Little Endian의 경우 상위 bit 주소(MSB)에 상위 주소를 저장한다.Big Endian의 경우 하위 bit 주소(LSB)에 상위 주소를 저장한다.대표적인 프로세서 중 하나인 ARM Procesor의 경우 Little Endian, Big Endian 모두를 지원하지만 default는 Little Endian이다." }, { "title": "등수 매기기", "url": "/posts/%EB%93%B1%EC%88%98-%EB%A7%A4%EA%B8%B0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-07-09 00:00:00 +0900", "snippet": "등수 매기기그리디 문제로, 동석차 없이 1~N까지 숫자를 줄세울 수 있도록 만드는 문제=&gt; 정렬하고 오차 발생시 절댓값의 오차 만큼을 정답 카운트에 더해줌#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N;vector&lt;int&gt; v;int main(void){\tlong long answer = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint num;\t\tscanf(\"%d\", &amp;num);\t\tv.push_back(num);\t}\tsort(v.begin(), v.end());\tfor (int i = 1; i &lt;= N; i++)\t{\t\tanswer += abs(i - v[i - 1]);\t}\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "단지번호붙이기", "url": "/posts/%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-08 00:00:00 +0900", "snippet": "단지번호붙이기BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define MAXLEN 25int N;int arrmap[MAXLEN][MAXLEN] = { { 0, }, };bool isvisited[MAXLEN][MAXLEN] = { { false, }, };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int cnt;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\t\t\tcnt++;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\t\t\t\tif (arrmap[nx][ny] == 1 &amp;&amp; isvisited[nx][ny] == false &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N)\t\t\t{\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\tisvisited[nx][ny] = true;\t\t\t\t\t\t\t}\t\t}\t}}int main(void){\tvector&lt;int&gt; v;\tint total_area = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%1d\", &amp;arrmap[i][j]);\t\t}\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tif (arrmap[i][j] == 1 &amp;&amp; isvisited[i][j] == false)\t\t\t{\t\t\t\tcnt = 0;\t\t\t\tisvisited[i][j] = true;\t\t\t\tbfs(i, j);\t\t\t\ttotal_area++;\t\t\t\tv.push_back(cnt);\t\t\t}\t\t}\t}\tsort(v.begin(), v.end());\tprintf(\"%d\\n\", total_area);\tfor (int i = 0; i &lt; v.size(); i++)\t{\t\tprintf(\"%d\\n\", v[i]);\t}\treturn 0;}" }, { "title": "유기농 배추", "url": "/posts/%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-04 00:00:00 +0900", "snippet": "유기농 배추BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int T, M, N, K;int field[50][50] = { { 0, }, };bool isvisited[50][50] = { {false, } };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int whitebug = 0;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\t\t\t\tif (isvisited[nx][ny] == false &amp;&amp; field[nx][ny] == 1 &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N)\t\t\t{\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\tisvisited[nx][ny] = true;\t\t\t}\t\t}\t}\treturn;}int main(void){\tint tmp_x, tmp_y;\tscanf(\"%d\", &amp;T);\tfor (int tc = 0; tc &lt; T; tc++)\t{\t\twhitebug = 0;\t\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);\t\tfor (int i = 0; i &lt; K; i++)\t\t{\t\t\t\tscanf(\"%d %d\", &amp;tmp_x, &amp;tmp_y);\t\t\tfield[tmp_y][tmp_x] = 1;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t{\t\t\t\tif (field[i][j] == 1 &amp;&amp; isvisited[i][j] == false)\t\t\t\t{\t\t\t\t\tisvisited[i][j] = true;\t\t\t\t\tbfs(i, j);\t\t\t\t\twhitebug++;\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"%d\\n\", whitebug);\t\tmemset(field, 0, sizeof(int) * 50 * 50);\t\tmemset(isvisited, false, sizeof(bool) * 50 * 50);\t}\t\treturn 0;}" }, { "title": "TASKING Compiler", "url": "/posts/TASKING_Complier/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-03 00:00:00 +0900", "snippet": "TASKING Compiler빌드 옵션clear, noclear초기화되지 않은 전역 변수의 경우 .bss 섹션에 저장된다.=&gt; 이 경우 Startup 코드에서 0으로 clear되는 것이 일반적초기화 되는 전역변수인 .data 섹션의 경우 noclear에 해당한다.이러한 clear와 no clear 를 빌드 옵션으로 지정할 수 있다.#include &lt;stdio.h&gt;#pragma noclearint init_data#pragma clear위의 예시에서 pragma 명령어를 통해 init_data를 프로그램 시작 시 전역에서 초기화 시키지 않고 이전 값을 유지하기 위하여 코드를 다음과 같이 설정했다.=&gt; .bss 섹션에 해당하는 변수이므로 Startup 코드에서 초기화되어야 하지만 그렇지 않은 것Section 코드 영역=&gt; 모든 코드의 경우 .text 섹션으로 정의한다. 변수 영역2.1 데이터 영역(.data)=&gt; 초기값이 있는 전역 변수가 이에 해당하고 ROM에 원본이 있고 RAM으로 copy하여 사용한다.2.2 .bss =&gt; 초기값이 없는 전역 변수로 RAM에만 세팅되어 사용된다2.3 .rodata=&gt; const 변수로 ROM에만 세팅된다또한 각 타입별로 3가지 접근 방식을 가질수 있고 그 내용은 다음과 같다. __far=&gt; 기본 타입으로 어떤 주소 번지에든 위치할 수 있다. __near=&gt; 섹션 타입 앞에 z가 붙고 각 세그먼트의 앞 16kb 에만 위치 가능 레지스터 타입(__a0, __a1)=&gt; 각 레지스터 타입 별 기준 주소가 존재하고 그 주소를 기준으로 16bit offset 공간에 위치 가능near 타입의 경우 가장 적은 어셈 라인으로 변수를 Read/Write 할 수 있다.=&gt; 속도 면에서 가장 효과적인 섹션 타입섹션 타입 지정 방법char __far ch1;char __a0 ch2;int __near var1;#pragma default_near_sizeint var1;int var2;#pragma default_near_size default" }, { "title": "그림", "url": "/posts/%EA%B7%B8%EB%A6%BC/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-02 00:00:00 +0900", "snippet": "그림BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘BFS 구현의 절차의 경우, 먼저 방문하지 않은 노드를 방문하고 방문 처리 및 큐에 넣는다. 큐에서 맨 앞 노드를 꺼내 인접 점을 탐색하고 방문하지 않았을 경우 큐에 넣는다. 넓이의 경우 큐에서 꺼낼 때 카운트를 하고 영역의 개수의 경우 최초 1을 발견하는 시점에 CNT를 수행한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, m;int draw[501][501];bool isivisited[501][501] = { { 0, }, };int dx[4] = { 0, 0, -1, 1 };int dy[4] = { -1, 1, 0, 0 };int area = 0, number = 0;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tint cnt = 0;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\tisivisited[cx][cy] = true;\t\tq.pop();\t\tcnt++;\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\tif (isivisited[nx][ny] == false &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m)\t\t\t{\t\t\t\tif (draw[nx][ny] == 1)\t\t\t\t{\t\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\t\tisivisited[nx][ny] = true;\t\t\t\t\t\t\t\t\t}\t\t\t}\t\t}\t}\tarea = max(cnt, area);}int main(void){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; m; j++)\t\t{\t\t\tscanf(\"%d\", &amp;draw[i][j]);\t\t}\t}\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; m; j++)\t\t{\t\t\tif (isivisited[i][j] == false &amp;&amp; draw[i][j] == 1)\t\t\t{\t\t\t\tbfs(i, j);\t\t\t\tnumber++;\t\t\t}\t\t\t\t\t}\t}\tprintf(\"%d\\n\", number);\tprintf(\"%d\\n\", area);\treturn 0;}" }, { "title": "좌표 정렬하기", "url": "/posts/%EC%A2%8C%ED%91%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-30 00:00:00 +0900", "snippet": "좌표 정렬하기c++의 vector와 pair를 활용한 정렬 기본문제#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N;int x[100001] = { 0, };int y[100001] = { 0, };bool compare(pair&lt;int, int&gt;a1, pair&lt;int, int&gt; a2){\tif (a1.second == a2.second)\t{\t\treturn a1.first &lt; a2.first;\t}\telse\t{\t\treturn a1.second &lt; a2.second;\t}}int main(void){\tvector&lt;pair&lt;int, int&gt;&gt; v;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint tmp_x = 0, tmp_y = 0;\t\tscanf(\"%d %d\", &amp;tmp_x, &amp;tmp_y);\t\tv.push_back(make_pair(tmp_x, tmp_y));\t}\tsort(v.begin(), v.end(), compare);\tfor (int i = 0; i &lt; N; i++)\t{\t\tprintf(\"%d %d\\n\", v[i].first, v[i].second);\t}\treturn 0;}" }, { "title": "수뒤집기", "url": "/posts/%EC%88%98%EB%92%A4%EC%A7%91%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-28 00:00:00 +0900", "snippet": "수뒤집기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int main(void){\tstring S;\tint zeroarea = 0, onearea = 0;\tbool flag = false;\tcin &gt;&gt; S;\tfor (int i = 0; i &lt; S.length(); i++)\t{\t\tif (S[i] != S[i+1])\t\t{\t\t\tif (S[i] == '0')\t\t\t\tzeroarea++;\t\t\telse\t\t\t\tonearea++;\t\t}\t}\tif(zeroarea &gt; onearea)\t\tcout &lt;&lt; onearea &lt;&lt; '\\n';\telse\t\tcout &lt;&lt; zeroarea &lt;&lt; '\\n';\treturn 0;}" }, { "title": "게임을 만든 동준이", "url": "/posts/%EA%B2%8C%EC%9E%84%EC%9D%84-%EB%A7%8C%EB%93%A0-%EB%8F%99%EC%A4%80%EC%9D%B4/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-28 00:00:00 +0900", "snippet": "게임을 만든 동준이오름차순을 만드는 문제로 볼 수 있고 따라서, 문제의 접근을 뒤에서부터 가지면 좋다.오름차순 =&gt;앞의 숫자보다 뒤의 숫자가 무조건 크면 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;int N;int point[100] = { 0, };int main(void){\tint answer = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;point[i]);\t}\tfor (int i = N - 1; i &gt; 0; i--)\t{\t\tif (N == 1)\t\t\tbreak;\t\twhile (point[i - 1] &gt;= point[i])\t\t{\t\t\tpoint[i - 1]--;\t\t\tanswer++;\t\t}\t}\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "주식", "url": "/posts/%EC%A3%BC%EC%8B%9D/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-18 00:00:00 +0900", "snippet": "주식그리디 문제로, 뒤의 날짜 즉 미래를 보면서 수익 계산을 하면 용이하다.뒤에서부터 최대 이익을 계산하면서 최고가를 보면 max_price값을 정정하면서 수익을 집계한다.(저가) -&gt; (연중 최고가, 매도) -&gt; (저가) -&gt; (저가) -&gt; (주중 최고가, 매도)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int T, N;int price[1000000] = { 0 };int main(void){\t\tscanf(\"%d\", &amp;T);\tfor (int i = 0; i &lt; T; i++)\t{\t\tll max_benefit = 0;\t\tscanf(\"%d\", &amp;N);\t\tfor(int j = 1; j &lt;= N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;price[j]);\t\t}\t\tint max_price = price[N];\t\tfor(int j = N - 1; j &gt; 0; j--)\t\t{\t\t\tif (max_price &lt;= price[j])\t\t\t{\t\t\t\tmax_price = price[j];\t\t\t}\t\t\telse\t\t\t{\t\t\t\tmax_benefit += (ll)(max_price - price[j]);\t\t\t}\t\t}\t\tcout &lt;&lt; max_benefit &lt;&lt; '\\n';\t}\t\treturn 0;}" }, { "title": "반복수열", "url": "/posts/%EB%B0%98%EB%B3%B5%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-18 00:00:00 +0900", "snippet": "반복수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_NUM 100000int N;int weight[MAX_NUM] = { 0 };int rope[MAX_NUM] = { 0 };int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;rope[i]);\t}\tsort(rope, rope + N, greater&lt;int&gt;());\tfor (int i = 0; i &lt; N; i++)\t{\t\tweight[i] = rope[i] * (i + 1);\t}\tsort(weight, weight + N, greater&lt;int&gt;());\tcout &lt;&lt; weight[0] &lt;&lt; '\\n';\treturn 0;}" }, { "title": "로프", "url": "/posts/%EB%A1%9C%ED%94%84/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-18 00:00:00 +0900", "snippet": "로프그리디 문제로, 병렬로 균등하게 무게가 배분되므로 로프의 하중 견디는 값이 높은 로프를 쓸수록 로프는 적게 쓸 수 밖에 없어진다.이를 생각하며 정렬을 사용하여 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_NUM 100000int N;int weight[MAX_NUM] = { 0 };int rope[MAX_NUM] = { 0 };int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;rope[i]);\t}\tsort(rope, rope + N, greater&lt;int&gt;());\tfor (int i = 0; i &lt; N; i++)\t{\t\tweight[i] = rope[i] * (i + 1);\t}\tsort(weight, weight + N, greater&lt;int&gt;());\tcout &lt;&lt; weight[0] &lt;&lt; '\\n';\treturn 0;}" }, { "title": "스타트업 코드(StartupCode)", "url": "/posts/StartupCode/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "스타트업(Startup) 코드란?프로그램이 작동되기 위해서 필요한 준비 과정을 위한 코드로 여러 초기화 작업과 C에서 사용할 메모리(스택, 힙) 등을 할당하고 마지막에 main() 함수를 호출하여 프로그램을 동작하게 한다.운영체제(OS)가 있는 경우의 main 호출 과정1. Shell 상에서 프로그램 수행2. fork로 새로운 프로세스 복사3. 시스템 콜 함수 sys_execve() 호출=&gt; 사용자 모드에서 커널 모드로 전환4. do_execve() =&gt; open_exec()로 파일 정보를 읽어 적합한 binary handler 실행5. flush_old_exec()가 기본 프로세스 정보를 삭제하고 현재 프로세스를 current 로 설정6. 새로운 프로세스에 사용할 메모리 레이아웃 설정7. 동적 링커 메모리에 로딩8. start_thread()=&gt; elf 인터프리터 실행9. sys_execve() 종료 =&gt; 커널 모드에서 사용자 모드로 전환10. reschedule() =&gt; context switching 수행11. _start_ 코드로 main 호출운영체제(Non-OS)가 없는 경우의 main 호출 과정프로그램이 작동되기 전 하드웨어의 초기화는 부트 코드에서, 임베디드 코드의 초기화는 스타트업 코드에서 처리한다1. 모든 인터럽트 중지2. 초기화된 데이터를 ROM to RAM 복사3. 초기화되지 않은 데이터 영역 0으로 초기화4. 스택을 위한 공간을 할당하고 초기화5. 프로세서의 스택 포인터 초기화6. 힙을 생성하고 초기화7. 인터럽트 활성화8. main() 함수 호출세부 설명1. 모든 인터럽트 중지=&gt; 스타트업 코드 실행 중에 인터럽트가 발생하여 ISR(Interrput Service Routine)으로 분기하면 해당 동작이 어떤 결과를 초래하는지 예측하기 어렵다따라서 인터럽트나 워치독(Watchdog)을 Disable 시킨다2. 초기화된 데이터를 ROM to RAM 복사=&gt; ROM에 있는 data segment를 RAM으로 복사한다bss segment의 경우 0으로 초기화 한다최종적으로 해당 과정들을 통해 임베디드 프로그램(C 프로그램) main()을 호출하고 스타트업 코드로 돌아오게 한다그 다음코드는 레이블 0만 반복하여 메모리가 임의의 주소로 빠지는 일을 막는다 " }, { "title": "MemoryMap", "url": "/posts/MemoryMap/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "Memory Map 에 관하여…Symbol 이란?Symbol은 Memory Map에서 Linker가 알아볼 수 있는 최소 단위를 말한다Linker의 Linking 과정 이후에 자신만의 주소를 갖게되는 단위를 말한다ELF File 형식에서 Linker에 의해 Symbol table을 두며 파일 단위의 관점에서 볼 때 참조되는 모든 Symbol의 이름과주소가 들어있고, 외부에서 선언된 Symbol은 없어 해당 Object에서 Symbol table은 불완전하다변수 관점에서는 Symbol은 Global 변수들을 나타낸다고 볼 수 있다.=&gt; 고유한 주소를 가지고 경우에 따라 다른 파일의 함수에서도 직접 접근하여 사용가능하다.Symbol을 성질에 따라 ZI, RO, RW 로 구별한다.ZI(Zero Initialization) : 초기 값이 0인 전역 변수(.bss)RO(Read Only) : 수정이 불가능한 const 전역변수와 text인 code(.text, .constdata)RW(Read Write) : 초기 값이 있는 전역 변수(.data)" }, { "title": "Embedded_c", "url": "/posts/Embedded_C/", "categories": "", "tags": "", "date": "2022-06-15 00:00:00 +0900", "snippet": "Embedded C 프로그래밍" }, { "title": "코드 최적화(CodeOptimization)", "url": "/posts/CodeOptimization/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "코드 최적화최적화의 등가교환(Trade-Off)크기 vs 속도성능 vs 가독성임베디드 소프트웨어의 최적화 규칙최선의 알고리즘, 최적의 코드를 찾아라하드웨어 특성(프로세서), 개발 툴 등을 잘 이해하고 활용하라헤더 인클루드 중복성 제거```C#ifndef FUNC_H// 정의가 되어있지 않을 경우 인클루드(딱 한번만 인클루드 하게 됨)#define FUNC_H/* 내용 */#endif FUNC_H```C에서 최적화를 위한 표현법비용이 낮은 연산자를 선택하라어셈블리 단에서 확인해보면, 나누기 곱셈과 같은 연산보다 비트 쉬프트 연산이 더 적은 명령어를 사용한다.따라서 2의 지수 승의 나누기 곱셈 연산을 할 때는 쉬프트 연산을 활용하는 것이 좋다Short Circuit 원리의 활용&amp;&amp; : 첫 비교문이 거짓이면 모두 거짓이므로, 뒤의 비교문은 보지 않는다.=&gt; 거짓의 확률이 높은 비교문을 앞에 둔다.|| : 첫 비교문이 참이면 모두 참이 되므로 그 뒤의 비교문은 모두 수행하지 않는다.=&gt; 참의 확률이 높은 비교문을 앞에 둔다.연관된 표현은 묶어서 처리한다=&gt; 이 부분의 경우 속도와 코드의 가독성의 Trade-off 관계실수 연산실수의 나누기는 느리다실수에서 나누기의 연산은 상당히 많은 연산시간을 잡아먹는다.가능하면 double 자료형 대신 float 자료형을 사용하라Math 라이브러리 함수를 되도록 사용하지 않는다=&gt; Math 라이브러리 함수들은 오버헤드가 크다.=&gt; 자주 사용되는 값을 테이블로 설정하여 사용한다.가능하면 고정 소수점으로 변환하여 사용하라" }, { "title": "최소직사각형", "url": "/posts/%EC%B5%9C%EC%86%8C%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "width와 height 중 width 가 더 크도록 정렬 후 sizes 벡터에 대해 max 값을 찾는다.#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; sizes) { int answer = 0; int w_max = 0, h_max = 0; for(int i = 0; i &lt; sizes.size(); i++) { if(sizes[i][0] &lt; sizes[i][1]) { int tmp = sizes[i][0]; sizes[i][0] = sizes[i][1]; sizes[i][1] = tmp; } } for(int i = 0; i &lt; sizes.size(); i++) { w_max = max(sizes[i][0], w_max); h_max = max(sizes[i][1], h_max); } answer = w_max * h_max; return answer;}" }, { "title": "약수의 개수와 덧셈", "url": "/posts/%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(int left, int right) { int answer = 0, div_num_cnt = 0; for(int i = left; i &lt;=right; i++) { div_num_cnt = 1; for(int j = 2; j &lt;= i; j++) { if(i % j == 0) { div_num_cnt++; } } if((div_num_cnt &amp; 1) == 0) { answer += i; } else { answer -= i; } } return answer;}" }, { "title": "부족한 금액 계산하기", "url": "/posts/%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "using namespace std;long long solution(int price, int money, int count){ long long answer = -1; long long total_price = 0; for(int i = 1; i &lt;= count; i++) { total_price += (price * i); } if(total_price &lt;= money) { answer = 0; } else { answer = total_price - money; } return answer;}" }, { "title": "로또의 최고 순위와 최저 순위", "url": "/posts/%EB%A1%9C%EB%98%90%EC%9D%98-%EC%B5%9C%EA%B3%A0-%EC%88%9C%EC%9C%84%EC%99%80-%EC%B5%9C%EC%A0%80-%EC%88%9C%EC%9C%84/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "정렬 이후 0은 어떠한 숫자로든 변할 수 있으므로 이에 따라 max와 min이 정해지는 것을 활용하여 문제 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) { vector&lt;int&gt; answer; int max_win = 0, min_win = 0; int answer_max = 0, answer_min = 0; sort(lottos.begin(), lottos.end()); sort(win_nums.begin(), win_nums.end()); for(int i = lottos.size() - 1; i &gt;= 0 ; i--) { for(int j = lottos.size() - 1; j &gt;= 0 ; j--) { if(lottos[i] == win_nums[j]) { max_win++; min_win++; break; } } } for(int i = 0; i &lt; lottos.size() ; i++) { if(lottos[i] == 0) { max_win++; } } switch(max_win) { case 1: answer_max = 6; break; case 2: answer_max = 5; break; case 3: answer_max = 4; break; case 4: answer_max = 3; break; case 5: answer_max = 2; break; case 6: answer_max = 1; break; default: answer_max = 6; } switch(min_win) { case 1: answer_min = 6; break; case 2: answer_min = 5; break; case 3: answer_min = 4; break; case 4: answer_min = 3; break; case 5: answer_min = 2; break; case 6: answer_min = 1; break; default: answer_min = 6; } answer.push_back(answer_max); answer.push_back(answer_min); return answer;}" }, { "title": "나머지가 1이 되는 수 찾기", "url": "/posts/%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%80-1%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(int n) { int answer = 0, x = 0; for(int i = 1; i &lt;= n; i++) { if(n % i == 1) { x = i; break; } } answer = x; return answer;}" }, { "title": "미로 탐색", "url": "/posts/%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-06-12 00:00:00 +0900", "snippet": "미로 탐색(bfs)bfs의 기초문제로 숫자가 붙어있어 데이터를 문자열로 받고 queue를 활용하여 bfs를 구현하여 문제를 해결한다.방문과 동시에 해당 좌표까지 도달하기 위한 cost(check 배열)을 이동 전 위치보다 +1를 하여 저장하면서 cost를 계산해나간다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int N, M;char arrmap[101][101];bool isvisited[100][100] = { { false } };int check[100][100] = { { 0 } };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int x, int y){ isvisited[x][y] = true; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(make_pair(x, y)); while(!q.empty()) { int cx = q.front().first; int cy = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) { int nx = cx + dx[i]; int ny = cy + dy[i]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if(isvisited[nx][ny] == false &amp;&amp; arrmap[nx][ny] == '1') { q.push(make_pair(nx, ny)); isvisited[nx][ny] = true; check[nx][ny] = check[cx][cy] + 1; } } } }}int main(void){ scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { scanf(\"%s\", arrmap[i]); } bfs(0, 0); printf(\"%d\", check[N-1][M-1] + 1); return 0;}" }, { "title": "Embedded C 프로그래밍", "url": "/posts/StartupCode/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "스타트업(Startup) 코드란?프로그램이 작동되기 위해서 필요한 준비 과정을 위한 코드로 여러 초기화 작업과 C에서 사용할 메모리(스택, 힙) 등을 할당하고 마지막에 main() 함수를 호출하여 프로그램을 동작하게 한다.운영체제(OS)가 있는 경우의 main 호출 과정1. Shell 상에서 프로그램 수행2. fork로 새로운 프로세스 복사3. 시스템 콜 함수 sys_execve() 호출=&gt; 사용자 모드에서 커널 모드로 전환4. do_execve() =&gt; open_exec()로 파일 정보를 읽어 적합한 binary handler 실행5. flush_old_exec()가 기본 프로세스 정보를 삭제하고 현재 프로세스를 current 로 설정6. 새로운 프로세스에 사용할 메모리 레이아웃 설정7. 동적 링커 메모리에 로딩8. start_thread()=&gt; elf 인터프리터 실행9. sys_execve() 종료 =&gt; 커널 모드에서 사용자 모드로 전환10. reschedule() =&gt; context switching 수행11. _start_ 코드로 main 호출운영체제(Non-OS)가 없는 경우의 main 호출 과정프로그램이 작동되기 전 하드웨어의 초기화는 부트 코드에서, 임베디드 코드의 초기화는 스타트업 코드에서 처리한다1. 모든 인터럽트 중지2. 초기화된 데이터를 ROM to RAM 복사3. 초기화되지 않은 데이터 영역 0으로 초기화4. 스택을 위한 공간을 할당하고 초기화5. 프로세서의 스택 포인터 초기화6. 힙을 생성하고 초기화7. 인터럽트 활성화8. main() 함수 호출세부 설명1. 모든 인터럽트 중지=&gt; 스타트업 코드 실행 중에 인터럽트가 발생하여 ISR(Interrput Service Routine)으로 분기하면 해당 동작이 어떤 결과를 초래하는지 예측하기 어렵다따라서 인터럽트나 워치독(Watchdog)을 Disable 시킨다2. 초기화된 데이터를 ROM to RAM 복사=&gt; ROM에 있는 data segment를 RAM으로 복사한다bss segment의 경우 0으로 초기화 한다최종적으로 해당 과정들을 통해 임베디드 프로그램(C 프로그램) main()을 호출하고 스타트업 코드로 돌아오게 한다그 다음코드는 레이블 0만 반복하여 메모리가 임의의 주소로 빠지는 일을 막는다 " }, { "title": "Memory Map 에 관하여...", "url": "/posts/MemoryMap/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "Memory Map 에 관하여…Symbol 이란?Symbol은 Memory Map에서 Linker가 알아볼 수 있는 최소 단위를 말한다Linker의 Linking 과정 이후에 자신만의 주소를 갖게되는 단위를 말한다ELF File 형식에서 Linker에 의해 Symbol table을 두며 파일 단위의 관점에서 볼 때 참조되는 모든 Symbol의 이름과주소가 들어있고, 외부에서 선언된 Symbol은 없어 해당 Object에서 Symbol table은 불완전하다변수 관점에서는 Symbol은 Global 변수들을 나타낸다고 볼 수 있다.=&gt; 고유한 주소를 가지고 경우에 따라 다른 파일의 함수에서도 직접 접근하여 사용가능하다.Symbol을 성질에 따라 ZI, RO, RW 로 구별한다.ZI(Zero Initialization) : 초기 값이 0인 전역 변수(.bss)RO(Read Only) : 수정이 불가능한 const 전역변수와 text인 code(.text, .constdata)RW(Read Write) : 초기 값이 있는 전역 변수(.data)" }, { "title": "Embedded C 프로그래밍", "url": "/posts/Embedded_C/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "Embedded C 프로그래밍ISR(Interrupt Service Routine)Interrupt handler 라고도 불리고 주로 외부 하드웨어적 요인이나 설정한 소프트웨어적 변경사항에 의해 발생하는 것을 사용자가 정의하고,그 일이 발생할 경우 현재의 작업을 중단하고 우선 처리하는 작업을 말한다.반대의 경우로는 폴링(Polling)이 있으며 폴링의 경우 해당 이벤트가 발생할 때까지 계속 확인하다가 발생하면 이벤트를 수행하는 것을 말한다.이러한 인터럽트가 걸렸다는 신호로 IRQ(Interrput Request)라는 것이 있고, 이 IRQ가 어떤 Interrupt에 해당하는지를 구별해준다.이러한 인터럽트에 관련된 플래그, 변수 등은 volatile로 선언된다.=&gt; 컴파일러 최적화 옵션에서 제외하여, 불분명한 결과를 야기하는 것을 피하기 위해서ISR 실행 과정 주 프로그램 실행 인터럽트 발생 복귀주소(PC) 저장 인터럽트 벡터로 점프 인터럽트 처리 인터럽트 처리 완료 복귀주소 로드 마지막에 실행된 주소로 점프 1번 과정 다음 PC 위치로 이동인터럽트 구성요소 우선순위=&gt; 2개 이상의 요청이 동시에 들어올 경우 어떤 우선 순위로 서비스를 실행하는가? 인터럽트 벡터(Interrput Vector)=&gt; 인터럽트 벡터는 인터럽트가 발생했을 때 할 일을 적어 놓은 것으로 ISR의 시작주소를 말한다. 발원지=&gt; 인터럽트가 발생한 지점이 어디인가?" }, { "title": "코드 최적화(CodeOptimization)", "url": "/posts/CodeOptimization/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "코드 최적화최적화의 등가교환(Trade-Off)크기 vs 속도성능 vs 가독성임베디드 소프트웨어의 최적화 규칙최선의 알고리즘, 최적의 코드를 찾아라하드웨어 특성(프로세서), 개발 툴 등을 잘 이해하고 활용하라헤더 인클루드 중복성 제거#ifndef FUNC_H// 정의가 되어있지 않을 경우 인클루드(딱 한번만 인클루드 하게 됨)#define FUNC_H/* 내용 */#endif FUNC_HC에서 최적화를 위한 표현법비용이 낮은 연산자를 선택하라어셈블리 단에서 확인해보면, 나누기 곱셈과 같은 연산보다 비트 쉬프트 연산이 더 적은 명령어를 사용한다.따라서 2의 지수 승의 나누기 곱셈 연산을 할 때는 쉬프트 연산을 활용하는 것이 좋다Short Circuit 원리의 활용&amp;&amp; : 첫 비교문이 거짓이면 모두 거짓이므로, 뒤의 비교문은 보지 않는다.=&gt; 거짓의 확률이 높은 비교문을 앞에 둔다.|| : 첫 비교문이 참이면 모두 참이 되므로 그 뒤의 비교문은 모두 수행하지 않는다.=&gt; 참의 확률이 높은 비교문을 앞에 둔다.연관된 표현은 묶어서 처리한다=&gt; 이 부분의 경우 속도와 코드의 가독성의 Trade-off 관계실수 연산실수의 나누기는 느리다실수에서 나누기의 연산은 상당히 많은 연산시간을 잡아먹는다.가능하면 double 자료형 대신 float 자료형을 사용하라Math 라이브러리 함수를 되도록 사용하지 않는다=&gt; Math 라이브러리 함수들은 오버헤드가 크다.=&gt; 자주 사용되는 값을 테이블로 설정하여 사용한다.가능하면 고정 소수점으로 변환하여 사용하라" }, { "title": "피보나치는 지겨웡~", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EB%8A%94-%EC%A7%80%EA%B2%A8%EC%9B%A1~/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치는 지겨웡~#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;int arr[51] = { 1, 1, 3, };void dp(int * arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i -1] + arr[i - 2] + 1) % 1000000007; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;n); dp(arr); return 0;}" }, { "title": "피보나치 수 7", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-7/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치 수 7#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;int arr[1000001] = { 0, 1, 1, };void dp(int * arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i - 1] + arr[i - 2]) % 1000000007; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;n); dp(arr); return 0;}" }, { "title": "피보나치 비스무리한 수열", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EB%B9%84%EC%8A%A4%EB%AC%B4%EB%A6%AC%ED%95%9C-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치 비스무리한 수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;long long arr[117] = { 0, 1, 1, 1, };void dp(long long * arr){ for(int i = 4; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 3]; } return;}int main(void){ scanf(\"%d\", &amp;n); dp(arr); cout &lt;&lt; arr[n] &lt;&lt; '\\n'; return 0;}" }, { "title": "파도반 수열", "url": "/posts/%ED%8C%8C%EB%8F%84%EB%B0%98-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "파도반 수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int T, N;int max_num = 0;long long arr[101] = { 0, 1, 1, };int main(void){ scanf(\"%d\", &amp;T); for(int i = 0; i &lt; T; i++) { scanf(\"%d\", &amp;N); if(N &lt; 3) { } else if(arr[N] == 0) { for (int i = 3; i &lt;= N; i++) { arr[i] = arr[i - 2] + arr[i - 3]; } } cout &lt;&lt; arr[N] &lt;&lt; endl; } return 0;}" }, { "title": "계단 오르기", "url": "/posts/%EA%B3%84%EB%8B%A8-%EC%98%A4%EB%A5%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "계단 오르기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int number;int score[301] = { 0 };int answer[301] = { 0 };void dp(int *arr){ answer[0] = arr[0]; answer[1] = arr[0] + arr[1]; answer[2] = max(arr[0] + arr[2], arr[1] + arr[2]); for(int i = 3; i &lt; number; i++) { answer[i] = max(answer[i - 2] + arr[i],answer[i - 3] + arr[i - 1] + arr[i]); }}int main(void){ scanf(\"%d\", &amp;number); for(int i = 0; i &lt; number; i++) { scanf(\"%d\", &amp;score[i]); } dp(score); printf(\"%d\", answer[number - 1]); return 0;}" }, { "title": "정렬(Sort)", "url": "/posts/Sort/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "SortC++ STL sort() 함수sort() 함수의 사용법은 아래 예시와 같이 배열의 시작점 주소와 마지막 주소+1 을 매개변수로 대입한다#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){ int arr[10] = {0,.3 ,5, 6, 2, 4, 2, 1, 3, 2}; sort(arr, arr+10); for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; ' '; } return 0;}또한 sort 함수의 새번째 매개변수로 함수를 받아 자신이 원하는 방식으로 정렬을 할 수 있게 한다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;/* 내림차순 정렬 함수 */bool compare(int a, int b){ return a &gt; b;}int main(void){ int arr[10] = {0,.3 ,5, 6, 2, 4, 2, 1, 3, 2}; sort(arr, arr+10, compare); for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; ' '; } return 0;}compare 함수 위치에는 greater&lt;int&gt;() =&gt; 내림차순 정렬, less&lt;int&gt;() =&gt; 오름차순 정렬(default)또한 특정 class 변수 혹은 구조체 변수일 경우 다음과 같은 방식으로 특정 변수를 기준으로 정렬이 가능해진다.Pair 라이브러리를 통한 정렬#include #include #include using namespace std;bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\tif (a.first == b.first) {\t\treturn a.second &lt; b.second;\t}\telse {\t\treturn a.first &lt; b.first;\t}}void init(vector&lt;pair&lt;int, int&gt;&gt; &amp;v){\tv.push_back({1, 13});\tv.push_back({5, 2});\tv.push_back({7, 14});\tv.push_back({1, 22});\tv.push_back({4, 3});}int main(){\tvector&lt;pair&lt;int, int&gt;&gt;v;\tinit(v);\tsort(v.begin(), v.end(), compare);\tfor(int i = 0; i &lt; v.size(); ++&gt;) {\t\tcout &lt;&lt; v[i].first &lt;&lt; \" \" &lt;&lt; v[i].second;\t}}" }, { "title": "에라토스테네스의 체(Sieve of Eratosthenes)", "url": "/posts/SieveofEratosthenes/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "Sieve of Eratosthenes(에라토스테네스의 체)소수 판별 알고리즘으로 주로 시간 제한이 걸려있는 소수 판별 문제에 사용한다그리고 대량의 숫자 범위 내의 소수 판정에 사용한다.기존 소수 판별 알고리즘 즉 그리디 방식의 경우 시간복잡도는 o(N^(1/2)) ~ o(N)기존 방식#include &lt;stdio.h&gt;#include &lt;math.h&gt;bool isPrime(int x){ int range = sqrt(x); // 두 숫자의 곱으로 표현될 때 각 약수들은 대칭을 이루기 때문에 제곱근까지만 파악하면 됨 for(int i = 2; i &lt;= range; i++) { if(x % i == 0) return False; } return True;}int main(void){ printf(\"%d\\n\". isPrime(123124)); return 0;}에라토스테네스의 체 알고리즘 방식은 대략적으로 다음과 같다 배열을 선언하고 탐색하고자 하는 범위내의 자연수를 넣는다. 2부터 시작하여 해당 숫자의 배수의 숫자들은 모두 지운다.(자기 자신은 지우지 않는다.)void PrimeSieve(int *arr){ for(int i = 2; i &lt; 100; i++) { if(arr[i] == 0) continue; for(int j = 2 * i; j &lt; 100; j += i) { arr[j] = 0; } } return ;}int main(void){ int arr[100] = { 0 }; for(int i = 2; i &lt; 100; i++) { arr[i] = i; } PrimeSieve(arr); for(int i = 2; i &lt; 100; i++) { printf(\"%d\\n\". arr[i]); } return 0;}" }, { "title": "해밍 가중치(Hamming Weight)", "url": "/posts/HammingWeight/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "해밍 가중치(Hamming Weight)길이가 모두 0인 Hamming Distance 와 동일/* Divide and Conquer */ int OneBitCnt(int data){ data = (data &amp; 0x55555555) + ((data &gt;&gt; 1) &amp; 0x55555555); //인접한 1비트의 분할정복 data = (data &amp; 0x33333333) + ((data &gt;&gt; 2) &amp; 0x33333333); //인접한 2비트의 분할정복 data = (data &amp; 0x0f0f0f0f) + ((data &gt;&gt; 4) &amp; 0x0f0f0f0f); //인접한 4비트의 분할정복 data = (data &amp; 0x00ff00ff) + ((data &gt;&gt; 8) &amp; 0x00ff00ff); //인접한 8비트의 분할정복 data = (data &amp; 0x0000ffff) + ((data &gt;&gt; 16) &amp; 0x0000ffff); //인접한 16비트의 분할정복 return data;} 모든 odd bit의 1값 탐색(data &amp; 0x55555555) 모든 even bit의 1값 탐색((data » 1) &amp; 0x55555555) 결과는 각 2비트씩 쪼개서 봤을 때 1의 개수를 이진수로 표현한 것과 같다. 이를 모두 더하면 전체 비트의 1의 개수와 같다 모든 하위 2비트 1값 탐색(data &amp; 0x33333333) 모든 상위 2비트 1값 탐색((data » 2) &amp; 0x33333333) 결과는 각 4비트씩 쪼개서 봤을 때 1의 개수를 이진수로 표현한 것과 같다. 이를 모두 더하면 전체 비트의 1의 개수와 같다…반복했을 때 최종적으로data = (data &amp; 0x0000ffff) + ((data » 16) &amp; 0x0000ffff);내용까지 수행하면 전체 비트의 1의 개수를 구할 수 있게 된다" }, { "title": "2×n 타일링 2", "url": "/posts/2-n-%ED%83%80%EC%9D%BC%EB%A7%81-2/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "2×n 타일링 2#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n = 0;long long arr[1001] = {0,1,3, };void dp(long long *arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i - 1] + 2 * arr[i - 2]) % 10007; } return;}int main(void){ long long answer = 0; scanf(\"%d\", &amp;n); dp(arr); cout &lt;&lt; arr[n] &lt;&lt; '\\n'; return 0;}" }, { "title": "1로 만들기", "url": "/posts/1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "1로 만들기#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N;int arr[1000001] = { 0, 0, 1, 1, };void dp(int * arr){ for(int i = 4; i &lt;= N; i++) { //먼저 1을 빼는 연산을 최솟값으로 설정 arr[i] = arr[i - 1] +1; // 3으로 나누는 연산과 1을 빼는 연산 간 크기 비교 if(i % 3 == 0) { arr[i] = min(arr[i], arr[i/3] + 1); } // 2으로 나누는 연산과 1을 빼는 연산 간 크기 비교 if(i % 2 == 0) { arr[i] = min(arr[i], arr[i/2] + 1); } } cout &lt;&lt; arr[N] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;N); dp(arr); return 0;}" }, { "title": "1, 2, 3 더하기", "url": "/posts/1,-2,-3-%EB%8D%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "1, 2, 3 더하기#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, T;int arr[11] = { 0, 1, 2, 4, };void dp(int * arr){ for(int i = 4; i &lt;= n; i++) { arr[i] = arr[i -1] + arr[i - 2] + arr[i - 3]; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;T); for(int i = 0; i &lt; T; i++) { scanf(\"%d\", &amp;n); dp(arr); } return 0;}" } ]
