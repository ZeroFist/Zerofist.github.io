<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zerofist.github.io//</id><title>ZeroFist's Software Engineering Knowledge Storage</title><subtitle>임베디드 ASW 엔지니어의 소소한 지식 저장소입니다.</subtitle> <updated>2022-07-27T22:01:00+09:00</updated> <author> <name>zerofist</name> <uri>https://zerofist.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://zerofist.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="ko-KR" href="https://zerofist.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 zerofist </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>N과 M (6)</title><link href="https://zerofist.github.io//posts/N%EA%B3%BC-M-(7)/" rel="alternate" type="text/html" title="N과 M (6)" /><published>2022-07-27T00:00:00+09:00</published> <updated>2022-07-27T00:00:00+09:00</updated> <id>https://zerofist.github.io//posts/N%EA%B3%BC-M-(7)/</id> <content src="https://zerofist.github.io//posts/N%EA%B3%BC-M-(7)/" /> <author> <name>zerofist</name> </author> <category term="CodingTest" /> <summary> N과 M (6) 순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다. 중복되는 순열을 출력 가능 =&amp;gt; 방문 여부 체크 X #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int N, M; int arr[9] = { 0, }; int ansarr[9] = { 0, }; void dfs(int cnt) { if (cnt == M) { for (int i = 0; i &amp;lt; M; i++) { printf("%d ", ansarr[i]); } printf("\n"); return; } for (int i = 0; i &amp;lt; N; i++... </summary> </entry> <entry><title>N과 M (6)</title><link href="https://zerofist.github.io//posts/N%EA%B3%BC-M-(6)/" rel="alternate" type="text/html" title="N과 M (6)" /><published>2022-07-23T00:00:00+09:00</published> <updated>2022-07-23T00:00:00+09:00</updated> <id>https://zerofist.github.io//posts/N%EA%B3%BC-M-(6)/</id> <content src="https://zerofist.github.io//posts/N%EA%B3%BC-M-(6)/" /> <author> <name>zerofist</name> </author> <category term="CodingTest" /> <summary> N과 M (6) 순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다. 중복되는 순열을 출력해해서는 안된다. =&amp;gt; 방문 여부 체크 사전 순 증가하는 순서로 출력해야한다. =&amp;gt; 배열 정렬 오름차순인 수열만 출력한다 =&amp;gt; 출력전 수열이 오름차순인지 체크 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int N, M; int arr[9] = { 0, }; int ansarr[9] = { 0, }; bool isvisited[10001] = { false, }; void dfs(int cnt) { if (cnt == M) { for (int i = 0;... </summary> </entry> <entry><title>N과 M (5)</title><link href="https://zerofist.github.io//posts/N%EA%B3%BC-M-(5)/" rel="alternate" type="text/html" title="N과 M (5)" /><published>2022-07-23T00:00:00+09:00</published> <updated>2022-07-23T00:00:00+09:00</updated> <id>https://zerofist.github.io//posts/N%EA%B3%BC-M-(5)/</id> <content src="https://zerofist.github.io//posts/N%EA%B3%BC-M-(5)/" /> <author> <name>zerofist</name> </author> <category term="CodingTest" /> <summary> N과 M (5) 순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다. 중복되는 순열을 출력해해서는 안된다. =&amp;gt; 방문 여부 체크 사전 순 증가하는 순서로 출력해야한다. =&amp;gt; 배열 정렬 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int N, M; int arr[9] = { 0, }; int ansarr[9] = { 0, }; bool isvisited[10001] = { false, }; void dfs(int cnt) { if (cnt == M) { for (int i = 0; i &amp;lt; M; i++) { printf("%d ", a... </summary> </entry> <entry><title>N과 M (3)</title><link href="https://zerofist.github.io//posts/N%EA%B3%BC-M-(4)/" rel="alternate" type="text/html" title="N과 M (3)" /><published>2022-07-23T00:00:00+09:00</published> <updated>2022-07-23T00:00:00+09:00</updated> <id>https://zerofist.github.io//posts/N%EA%B3%BC-M-(4)/</id> <content src="https://zerofist.github.io//posts/N%EA%B3%BC-M-(4)/" /> <author> <name>zerofist</name> </author> <category term="CodingTest" /> <summary> N과 M (4) 순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다. 조건 중 중요한 것은, 같은 수를 여러 번 골라도 된다. 고른 수열은 비내림차순이어야 한다. 길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다. 다음과 같이 다음 숫자가 이전 숫자보다 작아서는 안된다. 따라서 작은 경우 출력하지 않은 형태로 간단히 문제를 해결한다. #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int N, M; bool isvisited[8] = {false, }; int arr[8] = { 0, }; void dfs(int cnt) { if (cnt == M) { ... </summary> </entry> <entry><title>N과 M (3)</title><link href="https://zerofist.github.io//posts/N%EA%B3%BC-M-(3)/" rel="alternate" type="text/html" title="N과 M (3)" /><published>2022-07-23T00:00:00+09:00</published> <updated>2022-07-24T15:15:15+09:00</updated> <id>https://zerofist.github.io//posts/N%EA%B3%BC-M-(3)/</id> <content src="https://zerofist.github.io//posts/N%EA%B3%BC-M-(3)/" /> <author> <name>zerofist</name> </author> <category term="CodingTest" /> <summary> N과 M (3) 순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다. 같은 수를 여러번 체크해도 되므로 방문 문자열은 굳이 쓰지 않아도 된다. #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int N, M; int arr[8] = { 0, }; bool isvisited[8] = {false,}; void dfs(int cnt) { if (cnt == M) { for (int i = 0; i &amp;lt; M; i++) { printf("%d ", arr[i]); } cout &amp;lt;&amp;lt; '\n'; return ; } for (int i... </summary> </entry> </feed>
